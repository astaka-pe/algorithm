# Chap14 最短路問題

重みなしグラフの最短路 → BFSで求められる（[Chap13](../chap13))
本章では重みありの最短路問題を扱う

## 最短路問題の概要

### 負辺を持つグラフ

- アルゴリズム：**ベルマン・フォード法**
- 計算量： $O(|V||E|)$
- 方法：どの頂点から順に最短路が確定するかが非自明なので、 $|V|$ 回ループを回す

### 全て非負辺のグラフ

- アルゴリズム：**ダイクストラ法**
- 計算量： $O(|V|^2)$ or $O(|E| \rm{log} |V|)$
- 方法：どの頂点から順に最短路が確定するかは非自明

### DAG（有向閉路を持たないグラフ）

- アルゴリズム：**動的計画法**
- 計算量： $O(|V|+|E|)$
- 方法：どの頂点から順に最短路が確定するかが予め決まる

### 重みなしグラフ

- アルゴリズム：幅優先探索
- 計算量： $O(|V|+|E|)$
- 方法：[Chap13](../chap13) 参照
___
## 緩和

始点sから各頂点vへの最短路長を推定する値 `d[v]` を管理し、各辺についての緩和を繰り返す

- 辺 `e=(u, v)` についての緩和：`d[v] = min(d[v], d[u]+w[e])`

___
## DAG上の最短路問題：動的計画法

- DAGをトポロジカルソートすることで、緩和すべき辺の順序を明らかにする
- ソート順にいずれかの遷移形式で辺を緩和

## 単一始点最短路問題：ベルマン・フォード法

### 定理

- 始点sから到達可能な負閉路を持たない場合、高々 $|V|-1$ 回の反復によって`d[v]`が真の最短路長に収束する
  - この時、 $|V|$ 回目の反復を行なっても`d[v]`の値は更新されない
- sから到達可能な負閉路を持つならば、 $|V|$ 回目の反復時に`d[v]`が更新されるような辺が存在する

### 実装（例：[14-2.py](code/14-2.py)）

- 各辺について一通り緩和する操作を$|V|$回反復する
- $|V|$ 回目の操作で更新が発生するならば、始点sから到達可能な負閉路が存在することを意味する

### 正当性

- 到達可能な負閉路を持たないグラフ
  - 長さが最小の路 = 長さが最小の道（道：同じ頂点を2回以上通らない）
  - 路中に含まれる閉路を除去しても最短路長が増加することはない
  - 考察対象を道のみに限定できる
  - 路のうち、それに含まれる辺の本数が高々 $|V|-1$ 以下であるもののみを考えれば良い（全ての頂点を訪れたとしても辺数は $|V|-1$）
  - k回緩和操作を繰り返せば、スタート頂点からk近傍（辺数k個でたどり着ける）頂点までの最短路長が求められるので、 $|V|-1$ 回緩和を繰り返せば十分

- 負閉路を持つグラフ
  - 緩和を繰り返せば$N$回以降でも無限に最短路長が短くなる

## 単一始点最短路問題：ダイクストラ法

各辺が非負の場合、最短路推定値`d[v]`を動的に更新していく過程で、緩和を行うべき頂点順序が自動的に決まる

### 単純なダイクストラ法（実装例：[14-3.py](code/14-3.py)）

- 初期化
  - `d[s]=0`
  - `S={s}`: すでに最短路が求められていることが確定している頂点集合
  
- アルゴリズム
  - まだSに含まれていない頂点vのうち、`d[v]`が最小の頂点に着目
    - `d'[v]`は真の最短路長
  - 頂点vをSに挿入し、頂点vを始点とする各辺に対して緩和を行う
  - 全頂点がSに挿入されるまで繰り返す

- 直感的な理解
  - **未使用（未確定）の頂点のうちコストが最小の頂点には、それ以下のコストで辿り着くことができない**
- 正当性
  - 使用済みでない頂点のうち`d[v]`が最小の頂点vにおいて`d[v]=d'[v]`が成立することを数学的帰納法で示す
  - 全ての使用済み頂点uに対し、`d[u]=d'[u]`が成立していると仮定する
  - sからvへの最短路の一つをPとし、Pにおいてvの直前の頂点をuとする
  - uが使用済みである（uまでの最短路が求まっている）場合：
    - 仮定より`d[u]=d'[u]`
    - `(u, v)`の緩和`d[v]=min(d[v], d'[u]+w[e]=d'[v])`がすでに行われているため、`d[v]=d'[v]`
  - uが未使用の場合：
    - Pにおいてsから辿って最初の未使用頂点xとすると、`d[x]=d'[x]`
    - Pにおいて、sからxまでの部分も最短路となっている
    - 重みは非負なので、`d'[x]<=d'[v]`
    - 未使用頂点の中で距離dが最小の頂点がvなので、`d[v]<=d[x]`
    - よって、`d[v]<=d[x]=d'[x]<=d'[v]`となり、`d[v]=d'[v]`

- 特徴：密グラフで有利

### ヒープを用いるダイクストラ法（実装例：[14-4.py](code/14-4.py)）

`d[v]`が最小のvを求める部分をヒープを用いて高速化
- 最小値を取り出す部分は高速化できるが、緩和処理（ヒープの更新）に余分な時間がかかる
- 緩和処理の際に、ヒープのキー値を更新するのではなく、更新後の値を新たにヒープに挿入する
  - 同じ頂点に対して複数のキー値が存在することになるが、最小かつ最新のものが取り出されるので問題ない
- 特徴：疎グラフで有利

## 全点対間最短路問題：フロイド・ワーシャル法

グラフ上の全頂点対間について最短路長を求める


`dp[i][j][k]`: 頂点0, ..., k-1のみを中継頂点として通って良い場合の、iからjへの最短路長

- 初期条件 `dp[0][i][j]`:
  - 0 (i=j)
  - l(e) （eが存在)
  - ∞ （その他）

- `dp[k][i][j]`から`dp[k+1][i][j]`の値を更新する
  - 新たに使用できる**頂点kを使用しない**場合：`dp[k][i][j]`
  - 新たに使用できる**頂点kを使用する**場合：`dp[k][i][j] + dp[k][k][j]`

`dp[k+1][i][j] = min(dp[k][i][j], dp[k][i][j] + dp[k][k][j])`

- dpを3次元にする必要はない

```
for k in range(N):
    # 0, ..., k-1のみを通ってよい場合
    # dp[i][j]: iからjへの最短路長
    for i in range(N):
        for j in range(N):
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])
```

- `dp[v][v]<0`となるvが存在すれば、負閉路が存在することになる
