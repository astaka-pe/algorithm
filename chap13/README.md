# Chap13 グラフ探索

## 深さ優先探索と幅優先探索

### 深さ優先探索

- グラフ探索で用いるデータ（実装例：[13-1.py](code/13-1.py)）
  - `seen`（配列）：各頂点が `todo` に挿入された瞬間があったかどうかを表す
    - `seen[v]==False`: 頂点vが探索においてまだ見つかっていない状態
  - `todo`（スタックorキュー）：これから訪問する予定の頂点を格納

- 再帰関数を用いるとより簡潔に（`todo`を用いずに）実装できる（実装例：[13-2.py](code/13-2.py)）
  - 頂点vが`todo`から取り出されるタイミング = 再帰関数が呼び出されるタイミング

- 行きがけ順と帰りがけ順
  - 行きがけ順：各頂点が再帰関数**で呼び出される**タイミング順
    - vの子孫となる頂点はすべてvよりも**後**に登場
  - 帰りがけ順：各頂点が再帰関数**から抜ける**タイミング順
    - vの子孫となる頂点はすべてvよりも**前**に登場

### 幅優先探索

- 最短路アルゴリズムで用いるデータ（実装例：[13-3.py](code/13-3.py)）
  - `dist`: 各頂点までの最短路長（初期値は-1）
  - `que`: `todo`をキューにしたもの

- `dist`の値が小さくなるところから順に探索する
  - `dist==1`の頂点を探索 → `dist==2`の頂点を探索 → `dist==3`の頂点を探索...

### 計算量

グラフの性質により、頂点数 $|V|$ と辺数 $|E|$ のバランスが異なる
→ この2つで計算量を表す

- 各頂点に着目すると、それぞれ高々1回ずつ探索される（同じ頂点を二度探索することはない）
- 各辺に着目すると、それぞれ高々1回ずつ探索される（各辺の始点が二度探索されることはない）

→ 計算量は $O(|V|+|E|)$

### グラフ探索例

- s-tパスの判定（実装例：[13-4.py](code/13-4.py)）
- 2部グラフ判定（実装例：[13-5.py](code/13-5.py)）
- トポロジカルソート（実装例：[13-6.py](code/13-6.py)）
  - 与えられた有向グラフに対し、各頂点を辺の向きに沿うように順序づけて並び替える
  - 応用例：ビルドシステム（make）
  - ソート可能な必要十分条件：**有向サイクルを持たない**こと（directed acyclic graph, **DAG**）
  - アイデア：DFSの再帰関数を抜けた順序に頂点を並べ、それを逆順に並べ直すことでソート順が得られる
    - DFSでは頂点vから辿れる頂点全てについて再帰関数を終了して初めて、頂点vについての再帰関数も終了する（頂点vから辿れる頂点は全て先に再帰関数を抜ける）

- 木上の動的計画法
  - 根なし木に対して、ある頂点を根とすることで形成される根付き木の形状（頂点vの深さ、部分木のサイズ）を求める
    - 根なし木の操作（実装例：[13-7.py](code/13-7.py)）
    - 頂点vの深さ（実装例：[13-8.py](code/13-8.py)）
      - **行きがけ時**に求める
    - 部分木サイズ $=1+ \sum$ 子頂点の部分木サイズ（実装例：[13-9.py](code/13-9.py)）
      - **帰りがけ時**に求める
  - **木がサイクルを持たない性質**を利用すると、**DFS**で簡潔に実装できる
  